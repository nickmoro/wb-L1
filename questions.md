# Вопросы

### 1. Какой самый эффективный способ конкатенации строк?
Эффективнее всего будет хранить строки в срезе байт/рун и конкатенировать их, а в саму `string`
конвертировать лишь по завершению конкатенаций. Подобную реализацию предоставляет `strings.Builder`:
```golang
func Join(strs ...string) string {
    builder := strings.Builder{}
    for _, str := range strs {
        builder.WriteString(str)
    }
    return sb.String()
}
```

### 2. Что такое интерфейсы, как они применяются в Go?
Интерфейс описывает необхоидмый функционал (набор методов), которые должны быть реализованы у некоторой
другой структуры.

Например, перед нами задача реализовать обработчик HTTP-запросов: их суть, в общем, сводится к парсингу
тела запроса и выполнения определённых операций с базой данных. Представим, что взаимодействие с БД реализует
другой программист, либо мы пока не выбрали конкретную БД. В таком случае удобнее всего будет описать интерфейс
репозитория, который задаст набор нужных методов. Затем, мы реализуем хендлер запросов, используя этот интерфейс.
Во-первых, это позволит потенциальному коллеге меньше обращаться к нам с вопросами: у него есть чёткий интерфейс,
он его реализовывает. Во-вторых, это позволит в будущем сменить БД лишь реализовав структуру, взаимодействующую
с новой БД. В-третьих, во время тестирования нам проще будет сделать mock БД.

Пустой интерфейс (`interface{}`) реализован любой структурой, а значит к `interface{}` можно привести что угодно.
В свою очередь и из `data` типа `interface{}` можно получить любое значение при помощи конструкции
`val, ok := data.(type)`. Здесь `val` будет значением типа `type`, а `ok` покажет, удалось ли его извлечь. Так,
если мы попытаемся получить `string` из интерфейса, в котором "лежит" `int`, то получим `ok == false`.

### 3. Чем отличаются RWMutex от Mutex?
`Mutex` позволяет закрыть и открыть его (`Lock()`/`Unlock()`). Горутина, желающая закрыть (занять) мьютекс, сначала
дожидается его открытия (освобождения) горутиной, которая закрыла его. Обычно мьютексы хранят рядом с каким-то
объектом, реадктировать который одновременно из нескольких мест нельзя.

`RWMutex` же вводит дополнительный функционал (`RLock()`/`RUnlock()`): возможность несколько раз блокировать его
на чтение (концептуально, несколько горутин могут смотреть данные объекта одновременно, но не редактировать его).
При редактировании же придётся подождать, пока "подмьютексы" на чтение и на запись не станут открытыми. 

Можно сравнить это с листом бумаги за витриной: несколько людей могут читать текст на бумаге, но чтобы что-то
дописать, придётся загородить собой витрину и открыть её. В случае простого Mutex можем представить, что витрина
тонирована.

### 4. Чем отличаются буферизированные и не буферизированные каналы?

### 5. Какой размер у структуры struct{}{}?

### 6. Есть ли в Go перегрузка методов или операторов?

### 7. В какой последовательности будут выведены элементы map[int]int?

Пример:
```golang
m[0]=1
m[1]=124
m[2]=281
```

### 8. В чем разница make и new?

### 9. Сколько существует способов задать переменную типа slice или map?

### 10. Что выведет данная программа и почему?
```golang
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}
```

### 11. Что выведет данная программа и почему?
```golang
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
```

### 12. Что выведет данная программа и почему?
```golang
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
```

### 13. Что выведет данная программа и почему?
```golang
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}
```

### 14. Что выведет данная программа и почему?
```golang
func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}
```
