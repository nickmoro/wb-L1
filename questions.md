# Вопросы

### 1. Какой самый эффективный способ конкатенации строк?
Эффективнее всего будет хранить строки в срезе байт/рун и конкатенировать их, а в саму `string`
конвертировать лишь по завершению конкатенаций. Подобную реализацию предоставляет `strings.Builder`:
```golang
func Join(strs ...string) string {
    builder := strings.Builder{}
    for _, str := range strs {
        builder.WriteString(str)
    }
    return sb.String()
}
```

### 2. Что такое интерфейсы, как они применяются в Go?
Интерфейс описывает необхоидмый функционал (набор методов), которые должны быть реализованы у некоторой
другой структуры.

Например, перед нами задача реализовать обработчик HTTP-запросов: их суть, в общем, сводится к парсингу
тела запроса и выполнения определённых операций с базой данных. Представим, что взаимодействие с БД реализует
другой программист, либо мы пока не выбрали конкретную БД. В таком случае удобнее всего будет описать интерфейс
репозитория, который задаст набор нужных методов. Затем, мы реализуем хендлер запросов, используя этот интерфейс.
Во-первых, это позволит потенциальному коллеге меньше обращаться к нам с вопросами: у него есть чёткий интерфейс,
он его реализовывает. Во-вторых, это позволит в будущем сменить БД лишь реализовав структуру, взаимодействующую
с новой БД. В-третьих, во время тестирования нам проще будет сделать mock БД.

Пустой интерфейс (`interface{}`) реализован любой структурой, а значит к `interface{}` можно привести что угодно.
В свою очередь и из `data` типа `interface{}` можно получить любое значение при помощи конструкции
`val, ok := data.(type)`. Здесь `val` будет значением типа `type`, а `ok` покажет, удалось ли его извлечь. Так,
если мы попытаемся получить `string` из интерфейса, в котором "лежит" `int`, то получим `ok == false`.

### 3. Чем отличаются RWMutex от Mutex?
`Mutex` позволяет закрыть и открыть его (`Lock()`/`Unlock()`). Горутина, желающая закрыть (занять) мьютекс, сначала
дожидается его открытия (освобождения) горутиной, которая закрыла его. Обычно мьютексы хранят рядом с каким-то
объектом, реадктировать который одновременно из нескольких мест нельзя.

`RWMutex` же вводит дополнительный функционал (`RLock()`/`RUnlock()`): возможность несколько раз блокировать его
на чтение (концептуально, несколько горутин могут смотреть данные объекта одновременно, но не редактировать его).
При редактировании же придётся подождать, пока "подмьютексы" на чтение и на запись не станут открытыми. 

Можно сравнить это с листом бумаги за витриной: несколько людей могут читать текст на бумаге, но чтобы что-то
дописать, придётся загородить собой витрину и открыть её. В случае простого Mutex можем представить, что витрина
тонирована.

### 4. Чем отличаются буферизированные и не буферизированные каналы?
Буферизованный канал не блокирует горутину-отправитель до тех пор, пока не будет полностью заполнен.
Небуферизованный канал заблокируется до тех пор, пока другая горутина не считает из него данные.

### 5. Какой размер у структуры struct{}{}?
0 бит. Именно пустая структура многими используется для создания хеш-множества из хеш-мапы: в ключ кладётся
значение, а значением является пустая структура.

### 6. Есть ли в Go перегрузка методов или операторов?
Нет.

### 7. В какой последовательности будут выведены элементы map[int]int?
При использовании `fmt.Print(m)` значения будут выведены отсортированными по ключам. Сортировка происходит
внутри функции `fmt.Print`. В самой мапе же значения хранятся в произвольном порядке (вернее, порядок зависит
от хешей ключей).

### 8. В чем разница make и new?
`new` возвращает указатель на объект, а `make` – сам объект.  
`make` выделяет память и инциализирует только объекты следующих типов:
* `slice` – `make([]Type, len, cap)` инициализирует срез (динамический массив) с аллоцированной памятью под
`cap` элементов и заполненным `len` элементами со значениями по умолчанию типа `Type`. Параметр `cap` не
обязателен и равен 0 по умолчанию.
* `map` – `make(map[KeyType]ValType, cap)` инициализирует хеш-мапу (словарь на основе хеш-таблицы) с
аллоцированной памятью под `cap` элементов. Параметр `cap` не обязателен и равен 0 по умолчанию.
* `chan` – `make(chan Type, cap)` инициализирует канал для передачи элементов типа `Type`. Параметр `cap` не обязателен и равен 0 по умолчанию. При `cap > 0` канал считается буферизованным и может без блокировки считать
до `cap` объектов.

### 9. Сколько существует способов задать переменную типа slice или map?
1. При помощи make: `arr := make([]Type, len, cap)` и `dict := make(map[KeyType]ValType, cap)`.  
*Далее будем использовать `int` как `Type` и `ValType` и `string` как `KeyType`.*
2. При помощи списка инициализации: `arr := []int{1, 2, 3}` и `dict := map[string]int{"1": 2, "2": 2, "3": 3}.
3. При помощи опеределения переменной: `var arr []int` и `var dict map[string]int`.  
*Третий способ применяется редко. Стоит понимать, что `arr` и `dict` в таких случаях изначально равны nil.*

### 10. Что выведет данная программа и почему?
```golang
func update(p *int) {
    b := 2
    p = &b
}

func main() {
    var (
        a = 1
        p = &a
    )
    fmt.Println(*p)
    update(p)
    fmt.Println(*p)
}
```
Программа выведет `1 1`. Для вывода `1 2` необходимо в функции `update` присвоить не новое значение копии `p`,
а новое значение элементу, на которое `p` указывает, т.е. написать `*p = b` или `*p = 2`.

### 11. Что выведет данная программа и почему?
```golang
func main() {
    wg := sync.WaitGroup{}
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(wg sync.WaitGroup, i int) {
            fmt.Println(i)
            wg.Done()
        }(wg, i)
    }
    wg.Wait()
    fmt.Println("exit")
}
```
Произойдёт дедлок: `main` не дождётся обнуления счётчика `wg`, т.к. горутины применяют `wg.Done()` к копии `wg`.
Для исправления нужно передавать `wg` по указателю, либо не передавать в лямбда-функцию вовсе: нужное значение
будет захвачено из области видимости функции `main`. В таком случае будут в произвольном порядке выведены числа
от 0 до 4 на отдельных строках, а на последней строке – "exit".

### 12. Что выведет данная программа и почему?
```golang
func main() {
    n := 0
    if true {
        n := 1
        n++
    }
    fmt.Println(n)
}
```
Программа выведет `0`. Внутри `if` есть своя зона видимости, в которой создаётся отдельная переменная `n`.  
Для вывода `2` необходимо в блоке `if` присвоить значение (`n = 1`), а не создать новую переменную.

### 13. Что выведет данная программа и почему?
```golang
func someAction(v []int8, b int8) {
    v[0] = 100
    v = append(v, b)
}

func main() {
    var a = []int8{1, 2, 3, 4, 5}
    someAction(a, 6)
    fmt.Println(a)
}
```
Программа выведет `[100, 2, 3, 4, 5]`. Сам слайс – структура, хранящая длину и размерность слайса, а также
указатель на массив элементов. По копии указателя мы действительно можем изменить конкретный элемент: `v[0]`
будет изменено в исходном массиве. Функция `append` же возвращает слайс с указателем на новый массив, который
записывается в копию `v`.

### 14. Что выведет данная программа и почему?
```golang
func main() {
    slice := []string{"a", "a"}

    func(slice []string) {
        slice = append(slice, "a")
        slice[0] = "b"
        slice[1] = "b"
        fmt.Print(slice)
    }(slice)
    fmt.Print(slice)
}
```
Программа выведет `["b", "b", "a"]["a", "a"]`. В анонимной функции слайс после `append` будет новым.
Поэтому изменения в функции не повлияют на слайс в `main`.
